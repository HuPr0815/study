[toc]

### 笔记

#### 数据的表现形式及其运算



##### 常量与变量

*   常用的常量

    *   整型常量

        ~~~
        10, -10, 0
        ~~~

    *   实型变量

        *   十进制小数形式

            ~~~
            10.00, 0.10, -10.10, 0.00
            ~~~

        *   指数形式

            ~~~
            12.34E(12.34*(10**3)), -12.34e-10(12.34*(10**-10))
            注意：e或E之前必须有数字，且e或E后面必须为整数
            ~~~

    *   字符变量

        *   普通字符

            ~~~
            以单引号括起来的一个字符, 'a', '1', 'A', '?'
            字符常量储存在计算机存储单元中，并不是存储字符本身，而是以其代码(一般以ASCII代码)存储的
            ~~~

            <a src="./ASCII字符与代码对照表.png">ASCII字符与代码对照表</a>

        *   转义字符

            ~~~
            转义字符是一种特殊形式的字符常量，就是以字符\开头的字符序列
            ~~~

            <a src="./C语言转义字符对照表.png">C语言转义字符对照表</a>

    *   字符串常量

        ~~~
         以双引号括起来的若干字符
         注意：单引号内只能包含一个字符，双引号可以包含一个字符串
        ~~~

    *   符号常量

        ~~~
        用#define指令，指定一个符号名称代表一个常量
        #define 标识符 常量 //不用分号结尾
        注意：要区分符号常量和变量，不要把符号常量误认为变量
        	符号常量不占内存，只是一个临时符号，在预编译后这个符号就不存在了，故不能对符号常量赋予新值
        	为与变量名相区分，习惯上符号常量用大写表示
        ~~~

*   变量

    ~~~
    变量名：以一个名字代表的一个存储地址
    变量值：存放在变量的内存单元的数据
    变量必须先定义后使用
    每个变量必须被指定一种类型
    一般习惯上用小写表示变量
    在对程序编译连接时由编译系统给每一个变量名分配对应的内存地址。
    从变量中取值，实际上是通过变量名找到相应的内存地址，从该存储单元中读取数据
    ~~~

*   常变量

    ~~~
    const 类型 变量名=变量值;
    常变量与变量的异同：常变量具有变量的基本属性，有类型，占存储单元，只是不允许改变其值
    可以说，常变量是有名字的不变量，而常量是没有名字的不变量。有名字就便于在程序中引用
    ~~~

*   标识符

    ~~~
    标识符：用来对变量、符号常量名、函数、数组、类型等命名的有效字符序列
    C语言规定标识符只能由字母、数字和下划线三种字符组成，且不得以数字开头
    ~~~



##### 数据类型

*   类型

    ~~~
    类型就是对数据分配存储单元的安排，包括存储单元的长度(所占字节)以及数据的存储形式
    其中基本类型(包括整型和浮点型)和枚举类型变量的值都是数值,统称为算术类型
    算术类型和指针类型统称为纯量类型,因为其变量的值是以数字来表示的
    枚举类型是程序中用户定义的整数类型
    数组类型和结构体类型统称为组合类型,共用体类型不属于组合类型,因为在同一时间内只有一个成员具有值
    函数类型用来定义函数,描述一个函数的接口,包括函数返回值的数据类型和参数的类型
    ~~~

*   基本类型

    *   整型
        *   基本整型(int)
        *   短整型(short int)
        *   长整型(long int)
        *   双长整型(long long int)
        *   字符型(char)
        *   布尔型(bool)
    *   浮点型
        *   单精度浮点型(float)
        *   双精度浮点型(double)
        *   复数浮点型(float_complex, double_complex, long long_complex)

*   枚举类型(enum)
*   空类型(void)
*   派生类型
    *   指针类型(*)
    *   数组类型([])
    *   结构体类型(struct)
    *   共用体类型(union)
    *   函数类型

##### 整型数据

<table border="1" >
    <caption>整型数据常见的存储空间和值的范围</caption>
    <tr>
        <td>类型</td>
        <td>字节数</td>
        <td>取值范围</td>
    </tr>
    <tr>
        <td rowspan="2">int(基本整型)</td>
        <td>2</td>
        <td>-32768 ~ -32767, 即-2**15 ~ (2**15-1)</td>
    </tr>
    <tr>
        <td>4</td>
        <td>-2147483648 ~ 2147483648, 即-2**31 ~ (2**31-1)</td>
    </tr>
    <tr>
        <td rowspan="2">unsigned int(无符号基本整型)</td>
        <td>2</td>
        <td>0 ~ 65535, 即0 ~ (2**15-1)</td>
    </tr>
    <tr>
        <td>4</td>
        <td>0 ~ 4294967295, 即0 ~ (2**32-1)</td>
    </tr>
    <tr>
        <td>short(短整型)</td>
        <td>2</td>
        <td>-32768 ~ -32767, 即-2**15 ~ (2**15-1)</td>
    </tr>
    <tr>
        <td>unsigned short(无符号短整型)</td>
        <td>2</td>
        <td>0 ~ 65535, 即0 ~ (2**15-1)</td>
    </tr>
    <tr>
        <td>long(长整型)</td>
        <td>4</td>
        <td>-2147483648 ~ 2147483648, 即-2**31 ~ (2**31-1)</td>
    </tr>
    <tr>
        <td>unsigned long(无符号长整型)</td>
        <td>4</td>
        <td>0 ~ 4294967295, 即0 ~ (2**32-1)</td>
    </tr>
    <tr>
        <td>long long(双长整型)</td>
        <td>8</td>
        <td>-2**63 ~ (2**63-1)</td>
    </tr>
    <tr>
        <td>unsigned long long(无符号双长整型)</td>
        <td>8</td>
        <td>0 ~ (2**64-1)</td>
    </tr>
</table>



##### 字符型数据

~~~
由于字符是按照其代码(整数)形式存储的, 因此C 99把字符型数据作为整数类型的一种
字符与字符代码并不是任意写一个字符, 程序都能识别的.例如圆周率在程序中不能识别的,只能是习题的字符集中的字符(多指ASCII字符集)
~~~

*   字符型变量	

    ~~~
    如: char c = '?';
    定义c为字符型变量并使初值为字符'?','?'的ASCII代码是63,系统把整数63赋给变量c
    c是字符变量,实质上是一个字节的整型变量,由于它常用来存放字符,所以成为字符变量
    
    可以把0 ~ 127之间的整数赋给一个字符变量,在输出字符变量时可以选择十进制整数形式或者字符形式
    如: printf("%d %c", c, c)   ==>   63 ?
    
    说明: 在使用有符号字符型变量时, 允许存储的值为-128 ~ 127, 但字符的代码不可能为负值
    所以在存储字符时实际上只用到0 ~ 127这一部分, 其第1位都为0
    如果将一个负整数赋给有符号字符型变量是合法的,但它不代表一个字符,而作为一字节整型变量存储负整数
    且如果定义变量时不加前缀,c标准未规定默认值,由各编译系统决定
    ~~~

    <table>
        <caption>字符型数据的存储空间和值的范围</caption>
       <tr>
        	<td>类型</td>
       		<td>字节数</td>
           	<td>取值范围</td>
        </tr> 
         <tr>
        	<td>signed char(有符号字符型)</td>
       		<td>1</td>
           	<td>-128 ~ 127, 即-2**7 ~ (2**7-1)</td>
        </tr> 
         <tr>
        	<td>unsigned char</td>
       		<td>1</td>
             <td>0 ~ 255, 即0 ~ (2**8-1)</td>
        </tr> 
    </table>

##### 浮点型数据

~~~
浮点型数据是用来表示具有小数点的实数的
之所以叫做浮点型,是因为在C语言中,实数是以指数形式存放在存储单元中的,一个实数表示为指数可以有不止一种形式
如3.1415 ==> 3.1415*10**0 ==> 0.31415*10**1 ==> 0.031415*10**2 ==> 31.415*10**-1
由于小数点位置可以浮动,所以实数的指数形式称为浮点型
规范化的指数形式: 0.31415*10**1 ==> 0.31415e001
在存储时,系统将实型数据分成小数部分和指数部分分别存放
~~~

<table>
    <caption>实型数据的有关情况</caption>
    <tr>
        <td>类型</td>
        <td>字节数</td>
        <td>有效数字</td>
        <td>数值范围(绝对值)</td>
    </tr> 
    <tr>
        <td>float</td>
        <td>4</td>
        <td>6</td>
        <td>0以及1.2*10**-38 ~ 3.4*10**38</td>
    </tr> 
    <tr>
        <td>double</td>
        <td>8</td>
        <td>15</td>
        <td>0以及2.3*10**-308 ~ 1.7*10**308</td>
    </tr> 
    <tr>
        <td rowspan="2">long double</td>
        <td>8</td>
        <td>15</td>
        <td>0以及2.3*10**-308 ~ 1.7*10**308</td>
    </tr> 
    <tr>
        <td>16</td>
        <td>19</td>
        <td>0以及2.3*10**-308 ~ 1.7*10**308</td>
    </tr> 
</table>



##### 确定常量的类型

*   整型常量

    ~~~
    不带小数点的数值是整型常量, 但应注意其有效范围
    在一个整数末尾夹L或l, 表示它是长整型
    ~~~

    

*   浮点型常量

    ~~~
    凡是以小数形式或指数形式出现的实数是浮点型常量, 在内存中都已指数形式存储
    C编译系统把浮点型常量都按双精度处理, 分配八个字节, 所以C程序中的实型常量都是双精度浮点型常量
    如果有: float a = 3.14159;
    在进行编译时,对float变量分配4个字节,但对于浮点型常量3.14159,则按双精度处理,分配8个字节
    这时候编译系统会发出"警告"(warning: truncation from 'const double' to 'float')
    意思是: "把一个双精度常量转换为float型", 提醒用户这种转换可能会损失精度
    可以在常量末尾加专用字符,强制指定常量的类型
        float a = 3.14159f;
        long double a = 1.23L;
    ~~~



##### 运算符和表达式

~~~
两个实数相除的结果是双精度实数, 两个整数相除的结果为整数
但如果除数或者被除数有一个是负数, 则舍入的方向是不固定的, 但多数是向零取整
% 运算符要求参与运算的为整数,结果也为整数
~~~



<table>
    <caption>运算符优先级和结合性一览表</caption>
	<tbody>
		<tr>
			<th><p>优先级</p></th>
			<th><p>运算符</p></th>
			<th><p>名称或含义</p></th>
			<th><p>使用形式</p></th>
			<th><p>结合方向</p></th>
			<th><p>说明</p></th>
		</tr>
		<tr><td rowspan="4"><p>1</p></td><td><p>[]</p></td><td><p>数组下标</p></td><td><p>数组名[常量表达式]</p></td><td rowspan="4"><p>左到右</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>()</p></td><td><p>圆括号</p></td><td><p>(表达式)<br>
					函数名(形参表)</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>.</p></td><td><p>成员选择（对象）</p></td><td><p>对象.成员名</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>-&gt;</p></td><td><p>成员选择（指针）</p></td><td><p>对象指针-&gt;成员名</p></td><td>&nbsp;</td>
		</tr>
		<tr><td rowspan="9"><p>2</p></td><td><p>-</p></td><td><p>负号运算符</p></td><td><p>-表达式</p></td><td rowspan="9"><p>右到左</p></td><td><p>单目运算符</p></td>
		</tr>
		<tr><td><p>(类型)</p></td><td><p>强制类型转换</p></td><td><p>(数据类型)表达式</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>++</p></td><td><p>自增运算符</p></td><td><p>++变量名<br>
					变量名++</p></td><td><p>单目运算符</p></td>
		</tr>
		<tr><td><p>--</p></td><td><p>自减运算符</p></td><td><p>--变量名<br>
					变量名--</p></td><td><p>单目运算符</p></td>
		</tr>
		<tr><td><p>*</p></td><td><p>取值运算符</p></td><td><p>*指针变量</p></td><td><p>单目运算符</p></td>
		</tr>
		<tr><td><p>&amp;</p></td><td><p>取地址运算符</p></td><td><p>&amp;变量名</p></td><td><p>单目运算符</p></td>
		</tr>
		<tr><td><p>!</p></td><td><p>逻辑非运算符</p></td><td><p>!表达式</p></td><td><p>单目运算符</p></td>
		</tr>
		<tr><td><p>~</p></td><td><p>按位取反运算符</p></td><td><p>~表达式</p></td><td><p>单目运算符</p></td>
		</tr>
		<tr><td><p>sizeof</p></td><td><p>长度运算符</p></td><td><p>sizeof(表达式)</p></td><td>&nbsp;</td>
		</tr>
		<tr><td rowspan="3"><p>3</p></td><td><p>/</p></td><td><p>除</p></td><td><p>表达式 / 表达式</p></td><td rowspan="3"><p>左到右</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>*</p></td><td><p>乘</p></td><td><p>表达式*表达式</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>%</p></td><td><p>余数（取模）</p></td><td><p>整型表达式%整型表达式</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td rowspan="2"><p>4</p></td><td><p>+</p></td><td><p>加</p></td><td><p>表达式+表达式</p></td><td rowspan="2"><p>左到右</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>-</p></td><td><p>减</p></td><td><p>表达式-表达式</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td rowspan="2"><p>5</p></td><td><p>&lt;&lt;</p></td><td><p>左移</p></td><td><p>变量&lt;&lt;表达式</p></td><td rowspan="2"><p>左到右</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>&gt;&gt;</p></td><td><p>右移</p></td><td><p>变量&gt;&gt;表达式</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td rowspan="4"><p>6</p></td><td><p>&gt;</p></td><td><p>大于</p></td><td><p>表达式&gt;表达式</p></td><td rowspan="4"><p>左到右</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>&gt;=</p></td><td><p>大于等于</p></td><td><p>表达式&gt;=表达式</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>&lt;</p></td><td><p>小于</p></td><td><p>表达式&lt;表达式</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>&lt;=</p></td><td><p>小于等于</p></td><td><p>表达式&lt;=表达式</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td rowspan="2"><p>7</p></td><td><p>==</p></td><td><p>等于</p></td><td><p>表达式==表达式</p></td><td rowspan="2"><p>左到右</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>!=</p></td><td><p>不等于</p></td><td><p>表达式!= 表达式</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>8</p></td><td><p>&amp;</p></td><td><p>按位与</p></td><td><p>表达式&amp;表达式</p></td><td><p>左到右</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>9</p></td><td><p>^</p></td><td><p>按位异或</p></td><td><p>表达式^表达式</p></td><td><p>左到右</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>10</p></td><td><p>|</p></td><td><p>按位或</p></td><td><p>表达式|表达式</p></td><td><p>左到右</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>11</p></td><td><p>&amp;&amp;</p></td><td><p>逻辑与</p></td><td><p>表达式&amp;&amp;表达式</p></td><td><p>左到右</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>12</p></td><td><p>||</p></td><td><p>逻辑或</p></td><td><p>表达式||表达式</p></td><td><p>左到右</p></td><td><p>双目运算符</p></td>
		</tr>
		<tr><td><p>13</p></td><td><p>?:</p></td><td><p>条件运算符</p></td><td><p>表达式1? 表达式2: 表达式3</p></td><td><p>右到左</p></td><td><p>三目运算符</p></td>
		</tr>
		<tr><td rowspan="11"><p>14</p></td><td><p>=</p></td><td><p>赋值运算符</p></td><td><p>变量=表达式</p></td><td rowspan="11"><p>右到左</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>/=</p></td><td><p>除后赋值</p></td><td><p>变量/=表达式</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>*=</p></td><td><p>乘后赋值</p></td><td><p>变量*=表达式</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>%=</p></td><td><p>取模后赋值</p></td><td><p>变量%=表达式</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>+=</p></td><td><p>加后赋值</p></td><td><p>变量+=表达式</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>-=</p></td><td><p>减后赋值</p></td><td><p>变量-=表达式</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>&lt;&lt;=</p></td><td><p>左移后赋值</p></td><td><p>变量&lt;&lt;=表达式</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>&gt;&gt;=</p></td><td><p>右移后赋值</p></td><td><p>变量&gt;&gt;=表达式</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>&amp;=</p></td><td><p>按位与后赋值</p></td><td><p>变量&amp;=表达式</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>^=</p></td><td><p>按位异或后赋值</p></td><td><p>变量^=表达式</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>|=</p></td><td><p>按位或后赋值</p></td><td><p>变量|=表达式</p></td><td>&nbsp;</td>
		</tr>
		<tr><td><p>15</p></td><td><p>,</p></td><td><p>逗号运算符</p></td><td><p>表达式,表达式,…</p></td><td><p>左到右</p></td><td><p>&nbsp;</p></td>
		</tr>
	</tbody>
</table>



~~~
上表中可以总结出如下规律：
结合方向只有三个是从右往左，其余都是从左往右
所有双目运算符中只有赋值运算符的结合方向是从右往左
另外两个从右往左结合的运算符也很好记，因为它们很特殊：一个是单目运算符，一个是三目运算符
C语言中有且只有一个三目运算符
逗号运算符的优先级最低，要记住
此外要记住，对于优先级：算术运算符 > 关系运算符 > 逻辑运算符 > 赋值运算符。逻辑运算符中“逻辑非 !”除外
~~~



<table>
    <caption>一些容易出错的优先级问题</caption>
	<tbody>
		<tr>
			<th>
				优先级问题</th>
			<th>
				表达式</th>
			<th>
				经常误认为的结果</th>
			<th>
				实际结果</th>
		</tr>
		<tr>
			<td>
				. 的优先级高于 *（-&gt; 操作符用于消除这个问题）</td>
			<td>
				*p.f</td>
			<td>
				p 所指对象的字段 f，等价于：<br>
				(*p).f</td>
			<td>
				对 p 取&nbsp;f&nbsp;偏移，作为指针，然后进行解除引用操作，等价于：<br>
				*(p.f)</td>
		</tr>
		<tr>
			<td>
				[] 高于 *</td>
			<td>
				int *ap[]</td>
			<td>
				ap&nbsp;是个指向&nbsp;int&nbsp;数组的指针，等价于：<br>
				int (*ap)[]</td>
			<td>
				ap&nbsp;是个元素为&nbsp;int&nbsp;指针的数组，等价于：<br>
				int *(ap [])</td>
		</tr>
		<tr>
			<td>
				函数 () 高于 *</td>
			<td>
				int *fp()</td>
			<td>
				fp&nbsp;是个函数指针，所指函数返回&nbsp;int，等价于：<br>
				int (*fp)()</td>
			<td>
				fp 是个函数，返回&nbsp;int*，等价于：<br>
				int* ( fp() )</td>
		</tr>
		<tr>
			<td>
				== 和 != 高于位操作</td>
			<td>
				(val&nbsp;&amp;&nbsp;mask != 0)</td>
			<td>
				(val&nbsp;&p;mask) != 0</td>
			<td>
				val &amp;&nbsp;(mask != 0)</td>
		</tr>
		<tr>
			<td>
				== 和 != 高于赋值符</td>
			<td>
				c = getchar() != EOF</td>
			<td>
				(c = getchar()) != EOF</td>
			<td>
				c = (getchar() != EOF)</td>
		</tr>
		<tr>
			<td>
				算术运算符高于位移 运算符</td>
			<td>
				msb &lt;&lt;&nbsp;4 + lsb</td>
			<td>
				(msb &lt;&lt;&nbsp;4) + lsb</td>
			<td>
				msb &lt;&lt;&nbsp;(4 + lsb)</td>
		</tr>
		<tr>
			<td>
				逗号运算符在所有运 算符中优先级最低</td>
			<td>
				i = 1, 2</td>
			<td>
				i = (1,2)</td>
			<td>
				(i = 1),&nbsp;2</td>
		</tr>
	</tbody>
</table>



*   不同类型数据间的混合运算

    ~~~
    不同类型数据间的混合运算会先自动转换类型, 是两者具有同一种类型, 再进行运算
    1. + - * / 运算的两个数中有一个数是float或double型, 结果是double型,系统会将所有float转换成double再进行运算
    2. 如果int型与float或double型数据进行运算, 先把int型和float型数据转换成double型,结果是double
    3. 字符(char)型数据与整型数据进行运算,就是把字符的ASCII代码与整型进行运算,
    	字符型数据可以和整型数据直接运算,如果是和实型数据,则需要将字符的代码转换成double在进行运算
    ~~~

*   强制类型转换符

    ~~~
    (类型名) 表达式
    (double) a
    (int) (x+y)
    (float) (5%3)
    ~~~

*   C运算符

    ~~~
    算术运算符: + - * / % ++ --
    关系运算符: > < == >= <= !=
    逻辑运算符: ! && ||
    位运算符:   << >> ~ | ^ &
    赋值运算符: =及其扩展赋值运算符
    条件运算符: ? :
    逗号运算符: ,
    指针运算符: * &
    求字节数运算符: sizeof
    强制类型转换符: (类型)
    成员运算符: . - >
    下标运算符: []
    其他: 如函数调用运算符()
    ~~~

    

#### C语句



##### 赋值过程中的类型转换

*   将浮点型数据（包括单、双精度）赋给整型变量时，先对浮点数取整，舍弃小数部分，然后赋予给整型变量
*   将整型数据赋给单、双精度变量时，数值不变，但以浮点数形式存储但变量中
*   将一个double型数据赋给float变量时先将双精度转换为单精度，即只取6 ~ 7位有效数字，存储到float变量的4个字节中
*   字符型数据赋给整型变量时，将字符的ASCII代码赋给整型变量
*   将一个占字节多的整型数据赋给一个占字节少的整型变量或字符变量时，只将其低字节原封不动地送到被赋值的变量（截断）
*   要避免把高字节的整型数据向低字节的整型变量复制，有可能会发生失真，导致最终数值发生变化



##### 数据的输出 -- printf

<table>
    <caption>输出格式控制字符</caption>
	<tbody>
		<tr>
			<th>控制符</th>
			<th>说明</th>
		</tr>
		<tr>
			<td>%d</td>
			<td>按十进制整型数据的实际长度输出。</td>
		</tr>
		<tr>
			<td>%ld</td>
			<td>输出长整型数据。</td>
		</tr>
		<tr>
			<td>%md</td>
			<td>m 为指定的输出字段的宽度。如果数据的位数小于 m，则左端补以空格，若大于 m，则按实际位数输出。m前面加负号时向右端补齐空格。</td>
		</tr>
		<tr>
			<td>%u</td>
			<td>输出无符号整型（unsigned）。输出无符号整型时也可以用 %d，这时是将无符号转换成有符号数，然后输出。但编程的时候最好不要这么写，因为这样要进行一次转换，使 CPU 多做一次无用功。</td>
		</tr>
        <tr>
        	<td>%i</td>
            <td>作用与d格式符相同，按十进制整型数据的实际长度输出。一般使用%d</td>
        </tr>
		<tr>
			<td>%c</td>
			<td>用来输出一个字符。</td>
		</tr>
        <tr>
			<td>%s</td>
			<td>用来输出字符串。用 %s 输出字符串同前面直接输出字符串是一样的。</td>
		</tr>
		<tr>
			<td>%f</td>
			<td>用来输出实数，包括单精度和双精度，以小数形式输出。不指定字段宽度，由系统自动指定，整数部分全部输出，小数部分输出 6 位，超过 6 位的四舍五入。</td>
		</tr>
		<tr>
			<td>%m.nf</td>
			<td>输出实数时数据占 m 列，小数点后保留 n 位</td>
		</tr>
        <tr>
        	<td>%e 或 %E</td>
        </tr>
        <tr>
        	<td>%13.2e</td>
            <td>输出时整个指数占13列宽，小数点后取两位。</td>
        </tr>
        <tr>
        	<td>%g 或 %G</td>
            <td>用来输出浮点数，系统自动选f格式或e格式输出，选择其中长度较短的格式，不输出无意义的0</td>
        </tr>
		<tr>
			<td>%o</td>
			<td>以八进制整数形式输出，这个就用得很少了，了解一下就行了。</td>
		</tr>
		<tr>
			<td>%x（或 %X 或 %#x 或 %#X）</td>
			<td>以十六进制形式输出整数，大小写看x或X，前面加#输出时按标准十六进制格式</td>
		</tr>
        <tr>
        	<td>%%</td>
            <td>用于输出%符号</td>
        </tr>
    </tbody>    
</table>



##### 数据的输入 -- scanf



<table>
    <caption>输入格式控制表</caption>
	<tbody>
		<tr>
			<th width="120">格式控制符</th>
			<th>说明</th>
		</tr>
		<tr>
			<td>%c</td>
			<td>读取一个单一的字符</td>
		</tr>
        <tr>
			<td>%s</td>
			<td>读取一个字符串（以空白符为结束）</td>
		</tr>
		<tr>
			<td>%hd、%d、%ld</td>
			<td>读取一个十进制整数，并分别赋值给 short、int、long 类型</td>
		</tr>
		<tr>
			<td>%ho、%o、%lo</td>
			<td>读取一个八进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型</td>
		</tr>
		<tr>
			<td>%hx、%x、%lx</td>
			<td>读取一个十六进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型</td>
		</tr>
		<tr>
			<td>%hu、%u、%lu</td>
			<td>读取一个无符号整数，并分别赋值给 unsigned short、unsigned int、unsigned long 类型</td>
		</tr>
		<tr>
			<td>%f、%lf</td>
			<td>读取一个十进制形式的小数，并分别赋值给 float、double 类型</td>
		</tr>
		<tr>
			<td>%e、%le</td>
			<td>读取一个指数形式的小数，并分别赋值给 float、double 类型</td>
		</tr>
		<tr>
			<td>%g、%lg</td>
			<td>既可以读取一个十进制形式的小数，也可以读取一个指数形式的小数，并分别赋值给 float、double 类型</td>
		</tr>
		<tr>
        	<td>*</td>
            <td>这个是附加字符，表示本输入项在读入后不赋给相应变量</td>
        </tr>
	</tbody>
</table>

~~~
注意事项：
	scanf函数中的“格式控制”后面应当是变量地址，而不是变量名，也就是必须加上取地址符&
	如果在“格式控制”中除了格式声明以外还有其他字符，则在输入数据时在对应的位置上应输入与这些字符相同的字符
	在用“%c”格式声明输入字符时，空格字符和“转义字符”中的字符都作为有效字符输入
	在输入数值数据时，如输入空格、回车、Tab键或遇非法字符（不属于数值的字符），认为该数据结束
~~~



##### 字符数据的输入输出

*   用 putchar 函数输出一个字符

    ~~~
    可以输出普通字符、转义字符、ASCII字符
    putchar时输出字符的函数，字符类型也属于整数类型，因此蜀国整型数据在0 ~ 127的范围内
    ~~~

*   用 getchar 函数输入一个字符

    ~~~
    使用getchar函数，并不是在键盘上敲击一个字符，该字符就立即送到计算机。这些字符先暂存在键盘的缓冲器中
    只有按了回车键才把这些字符一起输入到计算机中，并按先后顺序赋给相应变量
    但如果回车键被快速按下，有一定可能回车键被当作是一个字符
    执行getchar函数不仅可以从输入设备获得一个可显示的字符，而且还可以获取无法显示的字符，如控制字符
    用getchar函数得到的字符可以赋给一个字符变量或整型变量，也可以不赋给任何变量，而作为表达式的一部分
    
    ~~~

##### 示例

~~~c
#include <stdio.h>
int main(){
	int fun1(){
		char a;
		scanf("%c",&a);
		printf("%d\n",a);
		printf("%c",a);
	}
	int fun2(){
		int a;
		scanf("%d",&a);
		printf("%d\n",a);
		printf("%c",a);	
	} 
	int fun3(){ 
		char a;
		a = getchar();
		printf("%d\n",a);
		printf("%c",a);	
	}
}
/*
fun1()
	a
    97
    a

fun2()
    65
    65
    A

fun3()
    a
    97
    a
*/
~~~



#### 数组



##### 定义一维数组

~~~
类型符 数组名[常量表达式]
类型符 数组名[常量表达式][常量表达式];（二维数组）
在定义数组时，需指定数组中元素的个数，方括号必须为常量或常量表达式，不可以用变量
但如果在被调用的含事故（不包括主函数）中定义数组，其长度可以是变量或非常量表达式
void func(int n){
	int a[2*n];
	...
}
在调用func函数时，形参n从实参得到值。这种情况成为“可变长数组”，允许在每次调用func函数时，n有不同值。
但在执行函数时，n的值是不变的，数组长度是固定的。
如果指定数组为静态（static）存储方式，则不能用“可变长数组”
~~~

##### 初始化一维数组

~~~
1. 在定义数组时对全部数组元素赋予初值
2. 可以只给数组中的一部分元素赋值，系统会给剩余未赋值的元素初始化为0（字符型数组为'\0'，指针型数组为'NULL'即空指针）
3. 在对全部数组元素赋初值时，由于数据的个数以及确定，因此可以不指定数组长度
~~~

##### 初始化二维数组

~~~
1. 分行赋值 int a[2][2]={{1,2},{3,4}};
2. 可以将所有数据卸载一个花括号内，按数组元素在内存中的排列顺序对个元素赋初值 int a[2][2]={1,2,3,4};
3. 可以对部分元素赋初值，其余未赋值元素自动为0（参考一维数组） int a[2][2]={{1},{}};
4. 如果对全部元素都赋初值（即提供全部初始数据），则定义数组时对第一维的长度可以不指定，但第二维必须指定
	int a[][2]={1,2,3,0}; <==> int a[2][2]={1,2,3,0}; <==> int a[][2]={{1,2},{3}}
~~~

##### 定义字符数组

~~~
定义字符数组的方法与定义数值型数组的方法类似
由于字符型数据是以整数形式（ASCII代码）存放，因此也可以用整型数组存放字符数据，这种方法合法但浪费存储空间
初始化与引用字符数组都与数值型数组相同
~~~

##### 字符串和字符串结束标志

~~~
在C语言中，是将字符串作为字符数组来处理的
在实际工作中，人们关心的往往是字符串的有效长度而不是字符数组的实际长度，
为了测定字符串的实际长度，c语言规定了一个“字符串结束标志”，即以字符“\0”作为结束标志
C系统在用字符数组存储字符串常量时会自动加一个'\0'作为结束符，字符串在数组中占的字节数会加1，即'\0'
所以在定义字符数组长度时，应大于最长字符串长度，留出位置给系统添加'\0'
~~~

##### 初始化字符数组

~~~
基本方法不尽相同，但字符数组有一种自己特殊的方法，可以省略花括号
char c[]={"Hello World!"}; <==> char c[]="Hello World!";
等价于 char c[]={'H','e','l','l','o',' ','W','o','r','l','d','!','\0'};
注意末尾的 '\0'
~~~

##### 字符数组的使用说明

~~~
字符数组并不要求它的最后一个字符为'\0'，甚至可以不包含'\0'，也是合法的
是否需要加'\0'，完全根据需求决定。由于系统在处理字符串常量储存时会自动加一个'\0'，
为了使处理方法一致，便于测定字符串的实际长度，以及在程序中作相应的处理，在字符数组中也常常认为地加上一个'\0'
~~~

##### 字符数组的输入输出

~~~
可以逐个字符输入输出，用格式符"%c"，也可以将整个字符串一次输入输出，用格式符"%s"
1. 输出的字符中不包括结束符'\0'
2. 用"%s"格式符输出字符串时，print函数中的输出项时字符数组名，而不是数组元素名
3. 如果数组长度大于字符串的实际长度，也只输出到遇'\0'结束
4. 如果一个字符数组中包含一个以上'\0'，则遇第一个‘、0’时输出就结束
5. 可以用scanf函数输入一个字符串，如果利用一个scanf函数同时输入多个字符串，应用空格分隔，
数组中未被赋值的元素的值自动置'\0'
	{
		char str[13];
		scanf("%s",str);
		-- How are you?
		-- str => {'H','o','w','\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'}
	}
	上面这种情况是因为系统把空格字符作为输入的字符串之间的分隔符
	scanf函数中的输入项如果时字符数组名，不要再加地址符&，因为在C语言中数组名代表该数组的起始地址
6. 前面提到的输出字符串的方法 printf("%s",c); 实际上的按下面这样执行的
	按字符数组名c找到其数组其实地址，然后逐个输出其中的字符，直到遇到'/0'为止
~~~

##### 使用字符串处理函数

==在使用字符串处理函数时应当在程序文件的开头引用 # include <string.h>==

*   puts 函数 —— 输出字符串的函数

    ~~~
    puts(字符数组)
    其作用是将一个字符串（以'\0'结束的字符序列）输出到终端
    在输出时将字符串结束标志'\0'转换成'\n'，即输出完字符串后换行
    puts(str); <==> printf("%s\n",str);
    ~~~

*   gets 函数 —— 输入字符串的函数

    ~~~
    gets(字符数组)
    其作用是从终端输入一个字符串到字符数组，并且得到一个函数值，该函数之是字符数组的起始地址
    在输入回车时才认为该字符串输入结束，这就解决了scanf函数不能接收带空格的字符串的问题
    ~~~

*   strcat 函数 —— 字符串连接函数

    ~~~
    strcat(字符数组1,字符数组2)
    其作用是把两个字符数组中的字符串连接起来，函数调用会得到一个函数值，是字符数组1的地址
    1. 字符数组1必须足够大，以便容纳连接后的新字符串
    2. 连接前两个字符串的1后面都有'\0'，连接时将字符串1后面的'\0'取消，只在新字符串后面保留'\0'
    ~~~

*   strcpy 和 strncpy 函数 —— 字符串复制函数

    ~~~
    strcpy(字符数组1,字符数组2)
    其作用是将字符串2复制到字符串1中去
    1. 字符数组1必须定义的足够大，以便容纳被复制的字符串2，字符数组1的长度不应小于v字符串2的长度
    2. “字符数组1”必须写成数组名形式，“字符串2”可以是字符数组名，也可以是一个字符串常量
    3. 如果在复制钱未对字符数组1初始化或赋值，则字符数组1的内容是无法预知的，复制时将字符数组2的字符串
    	和其后的'\0'一起复制到字符数组1中的前面，剩余的空间不一定是'\0'，而是字符数组1原来的内容
    4. 不能用赋值语句将一个字符串常量或字符数组直接给一个字符数组，只能用strcpy函数进行复制，用赋值语句只能将一个字符
    	赋给一个字符型变量或字符数组元素
    5. 可以用strncpy函数将字符串2中前面的n个字符复制到字符数组1中去 strncpy(str1, str2, n)
    	复制的字符个数不应多余str1中原有的字符（不包括'\0'）
    ~~~

*   strcmp 函数 —— 字符串比较函数

    ~~~
    strcmp(字符串1,字符串2)
    其作用是比较字符串1和字符串2，将两个字符串自左向右逐个字符相比，按ASCII码值大小比较，直到出现不同的字符或遇到'\0'
    两个字符串的比较不能直接有比较运算符，需要使用strcmp函数
    1. 如全部字符相同，则认为两个字符串相等
    2. 若出现不相同的字符，则以第一对不相同的字符的比较结果为准
    3. 返回函数值，相等返回0，大于返回一个正整数，小于返回一个负整数
    ~~~

*   strlen 函数 —— 测字符串长度函数

    ~~~
    strlen(字符数组)
    其作用是测试字符串常量的长度，函数值为字符串中的实际长度，也就是不包括'\0'
    ~~~

*   strlwr 函数 —— 转换为小写函数

    ~~~
    strlwr(字符串)
    其作用是将字符串中的大写字符转换成小写字母
    ~~~

*   strupr 函数 —— 转换为大写函数

    ~~~
    strupr(字符串)
    其作用是将字符串中的小写字符转换成大写字母
    ~~~

#### 函数

##### 函数的定义

~~~
定义函数应包含： 函数名 函数的类型（函数返回值） 函数的参数的名字和类型 函数的功能
类型名 函数名(形参 ){
	函数体
}
~~~

##### 函数的调用

~~~
1. 在定义函数中指定的形参，在未出现函数调用时，它们并不占用内存中的存储单元，在发生函数调用时，函数的形参被临时分配内存单元
2. 将实参对应的值传递给形参
3. 执行函数期间，由于形参已经有值，就可以利用形参进行有关的运算
4. 通过return语句将函数值带回到主调函数，如果函数是coid类型，则无返回值，无需return语句
5. 调用结束，形参单元被释放，但此时实参单元仍保留并维持原值，没有改变
实参向形参的数据传递是“值传递”，单向传递。实参和形参在内存中占有不同的存储单元，实参无法得到形参的值

~~~

##### 函数的递归

##### 数组作为函数参数

##### 局部变量和全局变量

*   局部变量

    ~~~
    定义变量：
    	1. 在函数开头定义
    	2. 在函数内复合语句内定义
    	3. 在函数外部定义
    在一个函数内定义的变量只在本函数内有效
    在复合语句内定义的变量只在本复合语句内有效
    在该复合语句以外是不能使用这些变量的
    
    1. 主函数中定义的变量（如m，n）也只在主函数中有效，并不因为在主函数中定义而在整个文件或程序中有效，主函数也不能使用其他函数中定义的变量
    2. 不同函数中可以使用同名的变量，他们代表不同的对象，互不干扰
    3. 形式参数也是局部变量
    4. 在一个函数内部，可以在复合语句中定义变量，这些变量只在本复合语句中有效，这种复合语句也称为“分程序“或”程序块“
    ~~~

    

*   全局变量

    ~~~
    在函数之外定义的变量成为外部变量，外部变量也称全局变量。全局变量可以为本文件中的其他函数所共用。他的有效范围为定义变量的位置开始到本源文件结束
    为了便于区别全局变量和局部变量，全局变量的第一个字母用大写表示
    
    全局变量的使用注意
    	1. 全局变量在程序的全部执行过程中都占用存储单元，而不是仅在需要时才开辟单元
    	2. 它使函数的通用性降低了
    	3. 使用全局变量过多，会降低程序的清晰性，人们往往难以清楚地判断出每个瞬时各个外部变量的值
    	4.如果在同一个源文件中，全局变量与局部变量同名，则按照就近原则
    	
    ~~~

##### 变量的存储方式和生存期

*   动态存储方式与静态存储方式

    ~~~
    有的变量在程序运行的整个过程都是存在的，而有的变量则是在调用其所在的函数时才临时分配存储单元，而在函数调用结束后该存储单元就马上释放了，变量就不存在了
    静态存储方式是指在程序运行期间由系统分配固定的存储空间的方式，而动态存储方式则是在程序运行期间根据需要进行动态的分配存储空间的方式
    存储空间：
    	1. 程序区
    	2. 静态存储区
    	3. 动态存储区
    在动态存储区中存放一下数据：
    	1. 函数形式参数。在调用函数时给形参分配存储空间
    	2. 函数中定义的没有用关键字static声明的变量，即自动变量
    	3. 函数调用时的现场保护和返回地址等
    在C语言中，每一个变量和函数都有两个属性：数据类型和数据的存储类别（数据在内存中存储的方式）
    存储类别：
    	1. auto（自动的）
    	2. static（静态的）
    	3. register（寄存器的）
    	4. extern（外部的）
    ~~~

*   局部变量的存储类别

    *   auto（自动变量）

        ~~~
        函数中的局部变量，如果不专门声明为static（静态存储类别），都是动态地分配存储空间的，数据存储在动态存储区中。函数中的形参和在函数中定义的局部变量（包括在复合语句中定义的局部变量），都属于此类。在调用该函数时，系统会给这些变量分配存储空间，在函数调用结束时就自动释放这些存储空间。
        实际上，关键字“auto”可以省略，不写“auto”则隐含指定为“自动存储类别”，它属于动态存储方式，程序中大部分变量属于自动变量。
        ~~~

    *   static（静态局部变量）

        ~~~
        有时希望函数中的局部变量的值在函数调用结束后不消失而继续保留原值，即其占用的存储单元不释放，在下一次再调用函数时，该变量已有值。这时就可以用静态局部变量
        1. 静态局部变量属于静态存储类别，在静态存储区内分配存储单元
        2. 对静态局部变量是在编译时赋初值的，即只赋初值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。而对自动变量赋初值，不是在编译时进行的，而是在函数调用时进行的，每调用一次函数重新给一次初值，相当于执行一次赋值语句
        3. 如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0或空字符'\0'。而对自动变量来说，它的值是一个不确定的值。这是由于每次函数调用结束后存储单元已释放，下次调用时又要重新另分配存储单元，而所分配的单元中的内容是不可知的（所以要养成赋初值的习惯）
        4. 虽然静态局部变量在函数调用结束后仍然存在，但其他函数是不能引用它的，因为它是局部变量，只能被本函数引用，而不能被其他函数引用。
        可以用在递归函数中
        ~~~

    *   register（寄存器变量）

        ~~~
        一般情况下，变量（包括静态存储方式和动态存储方式）的值是存放在内存中的，当程序中用到哪一个变量的值时，由控制器发出指令将内存中该变量的值送到运算器中。经过运算器运算，如果需要存数，再从运算器将数据送到内存存放。
        如果有一些变量使用频繁，为提高执行效率，允许将局部变量的值放在CPU中的寄存器，需要用时直接从寄存器去除参加运算，不必再到内存中去存取。由于对寄存器的存取速度远高于对内存的存取速度，因此这样做可以提高执行效率。
        ~~~
    ~~~
    
    ~~~

*   全局变量的存储类别

    *   在一个文件内扩展外部变量的作用域

        ~~~
        如果外部变量不再文件的开头定义，其有效作用范围只限于定义处到文件结束，在定义点之前的函数不能引用该外部变量
        这时可以用 extern 对该变量作外部变量声明，表示把该外部变量的作用域扩展到此位置
        提倡将外部变量的定义放在引用它的所有函数之前，避免多次使用extern
        使用extern时，类型名可以省略，因为它不是定义变量，可以不指定类型，只需写出外部变量名即可
        extern [类型名] 变量名;
        ~~~

    *   将外部变量的作用域扩展到其他文件

        ~~~
        如果一个程序包含两个文件，在两个文件中都要用到同一个外部变量，不能分别在两个文件中各自定义一个外部变量，否则在进行程序的连接时会出现“重复定义”的错误。
        这时候可以在另一个文件中用extern对变量作“外部变量声明”，即“extern 变量”。
    在编译和连接时，系统会由此知道变量有“外部链接”，可以从别处找到已定义的外部变量，并将在另一文件中定义的外部变量的作用域扩展到本文件，在文件中可以合法地引用外部变量 
        用这样方法扩展全局变量的作用域应十分谨慎，因为在执行一个文件中的操作时，可能会改变该全局变量的值，会影响到另一文件中全局变量的值，从而影响该文件中函数的执行结果
    实际上，在编译时遇到extern时，先在本文件中找外部变量的定义。如果找到，就在本文件中扩展作用域，如果找不到，就在连接时从其他文件中找外部变量的定义。如果从其他文件中找到了，就将作用域扩展到本文件，如果再找不到，就按出错处理。
        ~~~

    *   将外部变量的作用域限制在本文件中
    
        ~~~
        有时在程序设计中希望某些外部变量只局限于被本文件引用，这时可以使用 static 进行声明
        static 类型 变量名;
        这种加上static声明，只能用于本文件的外部变量称为“静态外部变量”
        用static声明一个变量的作用是：
        1. 对局部变量用static声明，把它分配在静态存储区，该变量在整个程序执行期间不释放，其分配的空间始终存在
        2. 对全局变量用static声明，则该变量的作用域只限于本文件模块（即被声明的文件中）
        ~~~

*   注意

    ==用auto，register和static声明变量时，是在定义变量的基础上加上这些关键字，==

    ==而不能单独使用，否则在编译时会被认为“重复定义”==

    



















### 课后习题

#### 第一章	程序设计与C语言

1. 什么是程序？什么是程序设计？

    ~~~de
    程序：计算机程序是一组能识别和执行的指令
    程序设计：是给出解决特定问题程序的过程
    ~~~
2. 为什么需要计算机语言？高级语言的特点？
   
   ~~~
   解决人与计算机之间交流的语言问题
   高级语言的特点：可读性高，接近自然语言，通用性强，易于移植
   ~~~
   
3. 正确理解以下名词及其含义。

    ```：
    （1）源程序 目标程序 可执行程序
    （2）程序编辑 程序编译 程序连接
    （3）程序 程序模块 程序文件
    （4）函数 主函数 被调用函数 库函数
    （5）程序调试 程序测试
    ```



#### 第二章	算法

1.  什么是算法？

    ~~~
    
    ~~~

2.  什么是结构化算法？为什么要提倡结构化的算法？

    ~~~
    
    ~~~

#### 第三章	顺序程序设计

1.  