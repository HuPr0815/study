## 目录

[toc]



## 一、数据结构与算法

### 数据结构的概念

> ```mermaid
> graph 
> 数据-->数据对象1
> 数据-->数据对象-->数据元素-->数据项1
> 数据对象-->数据元素2-->数据项2
> 数据元素-->数据项3
> 数据-->数据对象3
> ```
>
> 

#### 数据

>   数据是信息的载体。数据是对客观事物的符号表示，如图像、声音等。

#### 数据元素

>   数据元素是数据的基本单位.数据元素也称为元素、结点、顶点、记录等。

#### 数据项

>   数据项也称字段、域或属性，是具有独立含义的最小标识单位。一个数据元素也可以由若干个数据项组成。数据项是构成数据元素的不可分割的最小单位。
>
>   例如：一位学生的信息记录为一个数据元素，它由学号、姓名、性别等数据项组成。

#### 数据对象

> 数据对象是具有相同性质的数据元素的集合。

#### 数据结构

>   数据结构指的是数据元素之间的相互关系，即数据的组织形式。
>
>   数据结构是相互之间存在一种或多种特定关系的数据元素的集合。
>
>   数据结构的形式定义为：数据结构是一个二元组
>   $$
>   Data_Structure = (D, S)
>   $$
>   其中：D是数据元素的有限集，S是D上关系的有限集  
>
>   数据结构的三要素

##### 逻辑结构

>   数据的逻辑结构是指数据元素之间的 逻辑关系、
>
>   ```mermaid
>   graph 
>   逻辑结构-->集合
>   逻辑结构-->线性结构-->一对一
>   逻辑结构-->树形结构-->一对多
>   逻辑结构-->网状结构-->多对多
>   
>   ```
>
>   

##### 存储结构

>   数据的存储结构是指数据元素及数据元素之间的逻辑关系在计算机存储器内的表示
>
>   ```mermaid
>   graph 
>   存储结构-->顺序存储
>   存储结构-->链式存储
>   存储结构-->索引存储
>   存储结构-->散列存储
>   ```
>
>   

##### 数据的运算

>   数据的运算即对数据施加的操作。数据的运算定义在数据的逻辑结构上，只有确定了存储结构，才能具体实现这些运算
>
>   数据的运算通常包括以下5个操作

*   ==插入==：在指定位置上添加一个新结点
*   ==删除==：删去指定位置上的结点
*   ==更新==：修改某结点的值
*   ==查找==：寻找满足指定条件的结点及其位置
*   ==排序==：按指定顺序使结点重新排列

### 算法及算法分析  

#### 算法

> 算法是对特定问题求解步骤的一种描述，是求解步骤（指令）的有限序列。一个算法是将输入转换成输出的计算步骤。

#### 算法的重要特性

1. 输入

   > 一个算法应该有零个或多个输入

2. 有穷性

   > 一个算法必须在执行又穷步骤之后正常结束，而不能形成无穷循环

3. 确定性

   > 算法中的每一条指令必须有确切的含义，不能产生多义性

4. 可行性

   > 算法中的每一条指令必须是切实可执行的，即原则上可以通过已经实现的基本运算执行有限次来实现

5. 输出

   > 一个算法应该有一个或多个输出，这些输出是同输入有某个特定关系的量

#### 算法描述

1. 框图算法描述

   > 使用流程图或N-S图来描述算法

2. 非形式算法描述

   > 使用自然语言（中英文）和程序设计语言中的语句来描述算法。这类描述方法自然、简洁，但缺乏严谨性和结构性

3. 类高级语言算法描述

   > 使用类C的所谓伪语言来描述算法。这种算法不能直接在计算机上运行，但专业设计人员经常使用它来描述算法，它具有容易编写，阅读和格式统一的特点

4. 高级语言算法描述

   > 可以直接在计算机上运行并获得结果的算法

#### 算法与程序的关系

> 算法和程序都是用来表达解决问题的逻辑步骤；算法是对解决问题的方法的具体描述，程序是算法在计算机中的具体实现；程序是算法不一定是程序

#### 算法的设计要求

1. 正确性

   > 算法应能正确地实现预定的功能和处理要求

2. 易读性

   > 算法应易于阅读和理解，便于调试、修改和扩充

3. 健壮性

   > 正确的输入能得到正确的输出。当遇到非法输入是应能进行适当的反应或处理，而不会产生不需要或不正确的结果

4. 高效性

   > 解决同一问题的执行时间越短，算法的时间效率就越高

5. 低存储性

   > 解决同一问题的占用存储空间越少，算法的空间效率就越高

#### 影响算法运行时间的因素

1. 计算机硬件
2. 实现算法的语言
3. 编译生成的目标代码的质量
4. 问题的规模

#### 算法的时间复杂度

> 算法的时间效率分析：一个算法所耗费的时间，应该是该算法中每条语句的执行时间之和，而每条语句的执行时间是该语句的执行次数（也称为频度）与该语句执行一次所需时间的乘积。
>
> 算法效率的度量是通过时间复杂度和空间复杂度来描述的
>
> 算法的时间复杂度：设问题的规模为n，把一个算法的时间耗费 T(n) 称为该算法的时间复杂度，它是问题规模n的函数

* 算法的渐进时间复杂度

  > 设 T(n) 为一个算法的时间复杂度，如果当n趋向无穷大时 T(n) 与函数 f(n) 的比值的极限是一个非零常数M，即
  > $$
  > \lim_{a \rightarrow \infty} \frac{T(n)}{f(n)}=M\\
  > $$
  > 
  >
  > 记作
  > $$
  > T(n) = O(f(n))
  > $$
  > 
  >
  > 则称 O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度，也称T(n) 与 f(n) 的数量级相同。通常，f(n) 应该是算法中频度最大的语句的频度

  

* 常用算法的时间复杂度的顺序
  $$
  O(1)<O(log_2 n)<O(n)<O(n*log_2 n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
  $$
  
* 影响算法时间复杂度的因素

  > 算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关 

* 时间复杂度

  > O：最坏时间复杂度 （一般考虑的就是最坏时间复杂度）
  >
  > Ω：最优时间复杂度
  >
  > Θ：平均时间复杂度

* 时间复杂度的计算规则

  > 1. 基本操作，即只有常数项，认为其时间复杂度为O(1)
  >
  > 2. 顺序结构，时间复杂度按**加法**进行计算
  >
  > 3. 循环结构，时间复杂度按**乘法**进行计算
  >
  > 4. 分支结构，时间复杂度**取最大值**
  >
  > 5. 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略】
  >
  > 6. 加法规则：
  >    $$
  >    T(n,m) = T_1(n) + T_2(n) = O (max ( f(n),g(m) )
  >    $$
  >
  > 7. 乘法规则：
  >    $$
  >    T(n,m) = T_1(n) * T_2(m) = O (f(n) * g(m))
  >    $$

## 二、线性表

#### 线性表的类型定义

> 线性表是具有相同数据类型的n(n>=0) 个数据元素的有限序列
>
> 用L命名线性表，则其一般表示为
> $$
> L = (a_1,a_2,a_3,a_4,...,a_i,...,a_n)
> $$
> 除第一个元素外，每个元素有且仅有一个直接前驱
>
> 除最后一个元素以外，每个元素有且仅有一个直接后继

#### 线性表的基本操作

1. ==InitList( &L )==

   > 初始化表。构造一个空的线性表。

2. Length( L )

   > 求表长。返回线性表L的长度，即L中数据元素的个数。

3. LocateElem( L, e )

   > 按值查找操作。获取表L中查找具有给定关键字值得元素

4. GetElem( L, i )

   > 按位查找操作。获取表L中第 i 个位置得元素的值。

5. ListInsert( &L, i, e )

   > 插入操作。在表L中的第i个位置上插入指定元素e

6. ListDelete( &L, i, &e )

   > 删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。

7. PrintList( L )

   > 输出操作。按前后顺序输出线性表L的元素值。   

8. Empty( L )

   > 判空操作。

9. DestroyList( &L )

   > 销毁操作。

###  顺序表



#### 顺序表的结构

> 线性表的顺序存储称为顺序表，它是由一组地址连续的存储单元一次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻
>
> 

#### 顺序表的特点

> 顺序表最主要的特点是==随机存取==，即通过首地址和元素序号可在时间O(1)内找到指定元素。
>
> 顺序表的==存储密度高==，每个结点只存储数据元素。
>
> 顺序表逻辑上相邻的元素物理上也相邻，所以==插入和删除操作==需要移动大量元素

#### 基本操作

```c
  typedef struct alist *List;
  typedef struct alist
  {
    int maxsize;     // 表的最大长度
    int n;           // 表长
    ListItem *table; // 表元素数组
  } Alist;
  List ListInit(int size)
  /* 表结构初始化 */
  {
    List L = malloc(sizeof(*L));
    L->table = malloc(size * sizeof(ListItem));
    L->maxsize = size;
    L->n = 0;
    return L;
  }
  ListItem ListRetrieve(int k, List L)
  /* 返回表L位置k处的元素 */
  {
    if (k < 1 || k > L->n)
      Error("Out of bounds");
    return L->table[k - 1];
  }
  int ListLocate(ListItem x, List L)
  /* 返回元素x在表L中的位置 */
  {
    int i;
    for (i = 0; i < L->n; i++)
      if (L->table[i] == x)
        return ++i;
    return 0;
  }
  /* 在表L的位置k之后插入元素 */
  void ListInsert(int k, ListItem x, List L)
  {
    
    if (k < 0 || k > L->n)
      Error("Out of bounds");
      // 判断是否满表
    if (L->n == maxsize)
      Error("Out of bounds");
    // 参数不合理或表已满，插入不成功
    for (int i = L->n - 1; i >= k; i--)
    // 将k后面的每个数都往后移一位
    // 从后往前
      L->table[i + 1] = L->table[i];

    // 在k位置插入x
    L->table[k] = x;
    // 表长+1
    L->n++;
    }
   /* 从表L中删除位置k处的元素 */
  ListItem ListDelete(int k, List L)
  {
   
    int i;
    ListItem x; // 定义一个结构体变量
    // 判断k位置是否合法
    if (k < 1 || k > L->n)
      Error("Out of bounds");
      // 判断L是否是空表
    else if (L->n == 0)
      Error("List empty");
    else
    {
      // 存放k-1位置的值
      x = L->table[k - 1];
      // 将k位置后面的数都往前移一位
      for (i = k; i < L->n; i++)
        L->table[i - 1] = L->table[i];
      // 表长-1
      L->n - 1;
    }
    return x;
  }
```



#### 例题

> 将两个有序顺序表A, B合并为一个新的有序顺序表C，并用函数返回结果顺序表
>
> 算法思想：首先，按顺序不断取下两个顺序表表头较小的结点存入新的顺序表中。然后看哪个表还有剩余，将剩下的部分添加到新的顺序表后面
>
> ~~~c
> bool Merge( SqList A, SqList B, SqList &C) {
>     if ( A.length + B.length > C.MaxSize)
>         return false;
>     int i=0, j=0, k=0;
>     while ( i<A.length && j<B.length) {
>         if ( A.data[i] <= B.data[j] )
>             C.data[k++] = A.data[i++];
>         else
>             C.data[k++] = B.data[j++];
>     }
>     
>     while ( i<A.length ) 
>         C.data[k++] = A.data[i++];
>     while ( j<B.length )
>         C.data[k++] = B.data[j++];
>     C.length = k;
>     
> }
> ~~~
>

### 链表

#### 链表的有关概念



##### 结点的组成

> 线性表中的数据元素及元素之间的逻辑关系可由结点来表示。结点由两部分组成
>
> 1. 用来存储数据元素的值的==数据域==
> 2. 用来存储元素之间逻辑关系的==指针域==
>
> 指针域存放的是该结点的直接后继结点的地址

##### 单链表

> 用链式存储结构表示的线性表称为==链表==
>
> 即用一组任意（可以连续也可以不连续）的存储单元来存放线性表的结点，把每一个结点只有一个指针域的链表称为==单链表==

#####  开始结点、尾结点、头结点、头指针

> 1. 开始结点：在链表中存储的第一个数据元素的结点
>
> 2. 尾结点：存储最后一个数据元素的结点
>
>    ​					由于尾结点没有直接后继，所以尾结点指针域的值为NULL，用==^==表示
>
> 3. 头结点：在开始结点之前附加的一个结点称为头结点
>
> 4. 头指针：指向链表中第一个结点（头结点或无头结点的开始结点）的指针称为头指针

##### 结点的生成与释放

> * ==malloc==：向系统申请一个指定大小和类型的存储空间来生成一个新结点
>
>   ​						==p = (ListNode *)malloc(sizeof(ListNode))==
>
> * ==free(p)==：释放p指向的结点空间

#### 链表的基本操作

```c
#include <stdio.h>
int main()
{
  /* 结点的描述 */
  typedef char DataType; // 定义结点的数据域类型
  typedef struct node
  {
    // 结点类型定义
    DataType data;     // 结点的数据域
    struct node *next; // 结点的指针域
  } ListNode;          // 结构体类型标识符
  typedef ListNode *LinkList;
  ListNode *p;   // 定义一个指向结点的指针
  LinkList head; // 定义指向链表的头指针
  /* 链表的建立 */
  // 1. 头插法
  LinkList CreatListF(void)
  {
    // 返回单链表的头指针
    DataType ch;
    LinkList head;
    ListNode *s;
    head = NULL;
    printf("请输入链表各结点的数据(字符型):\n");
    while ((ch = getchar()) != "\n")
    {
      s = (ListNode *)malloc(sizeof(ListNode));
      if (s == NULL)
      {
        printf("申请存储空间失败! ");
        return s;
      }
      s->data = ch;   // 输入的数据写入结点数据域
      s->next = head; // 将新结点 *s 插入链表的前面
      head = s;       // 头指针指向新结点
    }
    return head;
  }
  LinkList CreatListRH(void)
  { //用尾插法建立带头结点的单链表
    DataType ch;
    LinkList head;
    ListNode *s, *r;
    head = (ListNode *)malloc(sizeof(ListNode));
    if (head == NULL)
    {
      printf("申请存储空间失败!");
      return head;
    }
    r = head; //尾指针初值也指向头结点
    printf("请输入链表各结点的数据(字符型):\n");
    while ((ch = getchar()) != '\n')
    {
      s = (ListNode *)malloc(sizeof(ListNode));
      if (s == NULL)
      {
        printf("申请存储空间失败!");
        return s;
      }
      s->data = ch;
      r->next = s; //将新结点插到链表尾
      r = s;       //尾指针指向新表尾
    }
    r->next = NULL;
    return head;
  }
  int LengthListH(LinkList head)
  {                     //求带头结点的单链表的表长
    ListNode *p = head; //p指向头结点
    int j = 0;
    while (p->next) //p->next与p->next!=NULL等价
    {
      p = p->next; //使p指向下一个结点
      j++;
    }
    return j;
  }
  int LengthList(LinkList head)
  {                     //求不带头结点的单链表的表长
    ListNode *p = head; //p指向开始结点
    int j;
    if (p == NULL) //处理空表
      return 0;
    j = 1; //处理非空表
    while (p->next)
    {
      p = p->next; //使p指向下一个结点
      j++;
    }
    return j;
  }
  ListNode *GetNode(LinkList head, int i)
  { /*在带头结点的单链表head中查找第i个结点，若找到（0≤i≤n），则返回该结点的存储地址，否则返回NULL。*/
    int j = 0;
    ListNode *p = head; //从头结点开始扫描
    while (p->next != NULL && j < i)
    {
      p = p->next;
      j++;
    }
    if (i == j)
      return p; //找到了第i个结点
    else
      return NULL;
  }
  ListNode *LocateNode(LinkList head, DataType key)
  { //在带头结点的单链表head中查找其值为key的结点
    ListNode *p = head->next;
    while (p && p->data != key)
      p = p->next;
    return p;
  }
  int InsertList(LinkList head, DataType x, int i)
  { //将值为x的新结点插入到带头结点的单链表head的第i个结点的位置上
    ListNode *p, *s;
    p = GetNode(head, i - 1); //寻找第i-1个结点
    if (p == NULL)
    {
      printf("未找到第%d个结点", i - 1);
      return 0;
    }
    s = (ListNode *)malloc(sizeof(ListNode));
    if (s == NULL)
    {
      printf("申请存储空间失败!");
      return 0;
    }
    s->data = x;
    s->next = p->next;
    p->next = s;
    return 1;
  }
  int DeleteList(LinkList head, int i)
  { //删除带头结点的单链表head上的第i个结点
    ListNode *p, *r;
    p = GetNode(head, i - 1); //找到第i-1个结点
    if (p == NULL || p->next == NULL)
    {
      printf("未找到第%d个结点或第d%个结点不存在。\n", i - 1, i);
      return 0;
    }
    r = p->next;       //使r指向被删除的结点ai
    p->next = r->next; //将ai从链上摘下
    free(r);           //释放结点ai的空间
    return 1;
  }
}

```

#### 循环链表

> ==循环链表==是一个首尾相接的链表，它是单链表的另一种形式
>
> ==单循环链表==是将单链表最后一个结点的指针域由NULL改为指向头结点或开始结点，所得到的单链表形式的循环链表

#### 双向链表

##### 双向链表的定义

> ==双向链表==：在单链表的每个结点里再增加一个指向其直接前驱结点的指针域prior，这样形成的链表中有两条方向不同的链
>
> ==双向循环链表==：将双向链表头结点和尾结点链接起来构成的循环链表

##### 双向链表的描述

> ```c
>   typedef char DataType; // 定义结点的数据域类型
>   typedef struct distnode {
>     // 结点类型定义
>     DataType data; // 结点的数据域
>     struct distnode *prior, *next; // 结点的指针域
>   } DListNode; // 结构体类型标识符
>   typedef DListNode *DLinkList; // 定义新指针类型
>   DListNode *p,*s; // 定义工作指针
>   DLinkList head; // 定义头指针
> ```
>
> * 双向（循环）链表的对称性：
>
>   ==前驱和后继双向都是对称的，其操作也都是镜像==
>
>   

##### 双向链表的前插操作算法

```c
int DInsertBefore(DListNode *p,DataType x)
{
	DListNode *s=( DListNode *)malloc(sizeof(DListNode));
	if(s==NULL)
	{
		printf("申请存储空间失败!");return 0;
	}
	s->data=x;
	s->prior=p->prior;
	s->next=p;
	p->prior->next=s;
	p->prior=s; 
	return 1;
}
```

##### 双向链表的删除当前结点的算法

```c
void DDeleteNode(DListNode *p)
{
	if(p->next)
{
p->prior->next=p->next;
		p->next->prior=p->prior;
	}
else
p->prior->next=NULL;
free(p);
}
```

##### 例题

```c
// 编写一个算法，在带头结点的双向链表中，将值为x的新结点插入结点*p之后，设p≠NULL。
int DInsertAfter(DListNode *p,DataType x)
{
	DListNode *s=( DListNode *)malloc(sizeof(DListNode));
	if(s==NULL)
	{
		printf("申请存储空间失败!");return 0;
	}
	s->data=x;
	s->next=p->next;
   p->next=s;
   s->prior=s->next->prior;
   s->next->prior=s;
	return 1;
}
```

### 线性表的应用

#### 顺序表的划分

```c
void Part(SeqList *L)
{
	int i,j;
	DataType x,y;			//用于存放基准和当前小于基准的结点
	x=L->data[0];			//将基准置入x中
	for(i=1;i<L->length;i++)
		if(L->data[i]<x)
		{
			y=L->data[i];	//将当前小于基准的置入y
			for(j=i-1;j>=0;j--)
				L->data[j+1]= L->data[j];
			L->data[0]=y;
		}
}
```

#### 有序顺序表的合并

```c
void Merge(SeqList A, SeqList B,SeqList *C)
{
	int i,j,k;
	i=0;j=0;k=0;
	while(i<A.length&&j<B.length)
	{
		if(A.data[i]<B.data[j])
			C-> data[k++]=A.data[i++];
		else
			C-> data[k++]=B.data[j++]; 
	}
	while(i<A.length)
		C-> data[k++]=A.data[i++];
	while(j<B.length) 
		C-> data[k++]=B.data[j++];
	C->length=k;
}
```

### 栈和队列

#### 栈的基本概念

> ==栈 (Stack)==是只允许在一端进行插入或删除操作的线性表，
>
> 限定这种线性表只能在某一端进行插入和删除操作
>
> ==栈顶==：线性表允许进行插入删除的那一端
>
> ==栈底==：不允许进行插入和删除的另一端
>
> ==空栈==：不含任何元素的空表
>
> 栈操作的特性是==先进后出==
>
> ![](./access/1.png)
>
> n个不同元素进栈，出栈元素不同排列的个数为
> $$
> \frac{1}{n+1}C^n_{2n}
> $$
>
> $$
> C^m_n=\frac{n!}{m!{(n-m)!}}
> $$

#### 顺序栈的基本运算

```c
#define MaxSize 100
typedef char ElemType;
typedef struct
{
	ElemType elem[MaxSize]; // 栈元素的定义
	int top; /*栈指针*/
} SqStack;
void InitStack(SqStack *&s)
{
	s=(SqStack *)malloc(sizeof(SqStack));
	s->top=-1; // 最开始栈指针指向-1
}
int Push(SqStack *&s,ElemType e)
{
	if (s->top==MaxSize-1) return 0; // 判定是否栈满
	s->top++;s->elem[s->top]=e;
	return 1;
}
int Pop(SqStack *&s,ElemType &e)
{
	if (s->top==-1) return 0;   // 判定是否栈空
	e=s->elem[s->top];
	s->top--;
	return 1;
}
```

#### 链栈的基本运算

```c
typedef char ElemType;
typedef struct linknode
{
    ElemType data; /*数据域*/
    struct linknode *next; /*指针域*/
} LiStack;
void InitStack(LiStack *&s)
{
	s=(LiStack *)malloc(sizeof(LiStack));
	s->next=NULL;
}
void Push(LiStack *&s,ElemType e)
{
    LiStack *p;
    p=(LiStack *)malloc(sizeof(LiStack));
    p->data=e;
    p->next=s->next; /*插入*p 结点作为第一个数据结点*/
    s->next=p;
}int Pop(LiStack *&s,ElemType &e)
{
    LiStack *p;
    if (s->next==NULL) /*栈空的情况*/
    return 0;
    p=s->next; /*p 指向第一个数据结点*/
    e=p->data;
    s->next=p->next;
    free(p);
    return 1;
}
```

#### 队列的基本概念

> ==队列==简称队。也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。
>
> 向队列中插入元素称为入队或进队；删除元素称为出队或离队
>
> 队列操作的特定是==先进先出==
>
> ==队头==：允许删除的一端，又称队首
>
> ==队尾==：允许插入的一端
>
> ![](./access/2.png)

#### 顺序队的基本运算

```c
#define MaxSize 5
typedef char ElemType;
typedef struct
{
ElemType elem[MaxSize];
int front,rear; /*队首和队尾指针*/
} SqQueue;
void InitQueue(SqQueue *&q)
{
q=(SqQueue *)malloc (sizeof(SqQueue));
q->front=q->rear=0;
}
int QueueLength(SqQueue *q)
{
return (q->rear-q->front+MaxSize)%MaxSize;
}
int enQueue(SqQueue *&q,ElemType e)
{if ((q->rear+1)%MaxSize==q->front) return 0; /*队满*/
q->rear=(q->rear+1)%MaxSize;
q->elem[q->rear]=e;
return 1;
}
int deQueue(SqQueue *&q,ElemType &e)
{
if (q->front==q->rear) /*队空*/ return 0;
q->front=(q->front+1)%MaxSize;
e=q->elem[q->front];
return 1;
}
```

#### 链队的基本运算

`````c
typedef char ElemType;
typedef struct qnode
{
    ElemType data;
    struct qnode *next;
} QNode;
typedef struct
{
    QNode *front;
    QNode *rear;
} LiQueue;
	void enQueue(LiQueue *&q,ElemType e)	
{
    QNode *s;
    s=(QNode *)malloc(sizeof(QNode));
    s->data=e;
    s->next=NULL;if (q->rear==NULL) /*若链队为空,则新结点是队首结点又是队尾结点
    */
    q->front=q->rear=s;
    else
    {
    q->rear->next=s; /*将*s 结点链到队尾,rear 指向它*/
    q->rear=s;
    }
}
int deQueue(LiQueue *&q,ElemType &e)
{
    QNode *t;
    if (q->rear==NULL) /*队列为空*/
    return 0;
    if (q->front==q->rear) /*队列中只有一个结点时*/
    {
    t=q->front;
    q->front=q->rear=NULL;
    }
    else /*队列中有多个结点时*/
    {
    t=q->front;
    q->front=q->front->next;
    }
    e=t->data;
    free(t);
    return 1;
}
void InitQueue(LiQueue *&q)
    {q=(LiQueue *)malloc(sizeof(LiQueue));
    q->front=q->rear=NULL;
}
void ClearQueue(LiQueue *&q)
{
    QNode *p=q->front,*r;
    if (p!=NULL) /*释放数据结点占用空间*/
    {
    r=p->next;
    while (r!=NULL)
    {
    free(p);
    p=r;
    r=p->next;
    }
    }
    free(q); /*释放头结点占用空间*/
}
int QueueLength(LiQueue *q)
{
    int n=0;
    QNode *p=q->front;
    while (p!=NULL)
    {
    n++;
    p=p->next;
    }
    return(n);
}
`````

